# 4.1 NORMALIZATION

Normalization is a systematic approach to organizing data in a database to reduce redundancy and improve data integrity. The process involves decomposing tables into smaller, well-structured relations that minimize duplication while preserving the ability to reconstruct the original data through joins. For the OralCare AI system, proper normalization ensures that the database schema is efficient, maintainable, and capable of supporting complex queries without anomalies that could compromise data quality or application functionality. The normalization process follows established normal forms, each addressing specific types of redundancy and dependency issues that can plague poorly designed databases.

The OralCare AI database schema has been designed following normalization principles up to Third Normal Form (3NF), which represents a practical balance between normalization benefits and query performance for most applications. The design process began with identifying all data elements required by the application including user information, image metadata, detection results, reports, and activity logs, then organizing these elements into tables based on their natural relationships and dependencies. The resulting schema eliminates most redundancy while maintaining referential integrity through foreign key constraints and supporting the full range of application queries efficiently through appropriate indexing.

## First Normal Form (1NF)

First Normal Form requires that all table columns contain atomic values, meaning each column holds only a single value rather than lists, sets, or other compound structures. Additionally, each column must contain values of a single type, and each row must be uniquely identifiable through a primary key. The OralCare AI schema satisfies 1NF through several design decisions that ensure data atomicity and uniqueness across all tables.

The Users table stores each attribute as a single value, with separate columns for first_name, last_name, email, username, role, and institution rather than combining related information into compound fields. User roles are stored as single values from an enumerated set (admin, doctor, researcher, student) rather than as comma-separated lists of multiple roles, ensuring that role assignment is atomic and queryable. Each table includes a UUID primary key providing guaranteed uniqueness across all records, even if other attributes like email addresses are modified. The Images table maintains atomicity by storing each image attribute separately, with filename as a string, file_size as an integer, upload_date as a timestamp, and status as an enumerated value. The file_url pointing to Supabase Storage contains a single URL string rather than multiple references, and if an image needs to be stored in multiple locations for redundancy, separate records would be created rather than storing multiple URLs in a single column.

The DetectionResults table similarly stores atomic values for model_name (RegNetY320 or VGG16), prediction (Cancer or Non-Cancer), confidence_score as a floating-point number, and processing_time as a decimal value. This atomic structure enables straightforward querying such as filtering images by status or finding detection results above a confidence threshold without complex string parsing or array manipulation. All timestamp fields use the TIMESTAMP WITH TIME ZONE data type ensuring temporal data is stored atomically with timezone information, preventing ambiguity in temporal ordering across geographic locations.

## Second Normal Form (2NF)

Second Normal Form builds on 1NF by requiring that all non-key attributes be fully functionally dependent on the primary key, eliminating partial dependencies where an attribute depends on only part of a composite primary key. While the OralCare AI schema primarily uses single-column UUID primary keys that automatically avoid partial dependency issues, the design principles of 2NF still inform table structure decisions ensuring clean functional dependencies throughout the schema.

The DetectionResults table demonstrates proper 2NF structure where all attributes including model_name, prediction, confidence_score, and processing_time depend on the detection result ID and not on any partial key. If the table used a composite key of (image_id, model_name), then attributes like image upload_date that depend only on image_id would violate 2NF and should be moved to the Images table. The current design with UUID primary keys naturally satisfies 2NF by making all non-key attributes dependent on the single-column primary key.

The Reports table maintains 2NF by ensuring that all report attributes depend on the report_id primary key. Patient information like patient_name and patient_age are stored in the Reports table because they are specific to each report rather than being general properties of users or images. If the system evolved to track patients as first-class entities with multiple reports over time, a separate Patients table would be created to avoid storing patient information redundantly across multiple reports, maintaining 2NF while supporting more complex patient management workflows. The current design makes a pragmatic tradeoff accepting some patient information duplication in exchange for query simplicity, which is reasonable given that most reports are one-time snapshots rather than longitudinal patient records.

## Third Normal Form (3NF)

Third Normal Form extends 2NF by eliminating transitive dependencies where non-key attributes depend on other non-key attributes rather than depending directly on the primary key. The OralCare AI schema achieves 3NF through careful separation of concerns across tables, ensuring that each attribute depends directly on its table's primary key without intermediate dependencies through other non-key columns.

The Users table stores only attributes intrinsic to users themselves, with role stored directly rather than deriving it from other attributes like institution or job_title. If the design included derived attributes like age calculated from birth_date, these would violate 3NF and should be computed in application code rather than stored redundantly in the database where they could become inconsistent if the birth_date changes. The relationship between Images and DetectionResults exemplifies 3NF structure where the DetectionResults table stores model predictions and confidence scores that depend directly on the detection result itself, while image-specific information like filename and upload_date remains in the Images table.

The detection result doesn't store the user_id even though it could be derived from the associated image's user_id, avoiding transitive dependency and ensuring that user relationships are managed through the Images table. When a query needs to find all detection results for a specific user, it joins DetectionResults to Images to Users, traversing the explicit relationships rather than relying on redundant user references. The UserActivity table for audit logging maintains 3NF by storing activity_type, timestamp, ip_address, and description as attributes directly dependent on the activity record itself. If activities needed to track the user's institution at the time of the activity, this would be stored in the activity record rather than looked up from the current Users table, because the user's institution might change over time and historical activity logs should reflect the state at the time the activity occurred rather than the current state.

## Denormalization Considerations

While normalization reduces redundancy and improves data integrity, highly normalized schemas can require complex joins that impact query performance. The OralCare AI design includes strategic denormalization decisions that trade some redundancy for improved performance or simplified queries. The Images table stores both file_url pointing to Supabase Storage and file metadata like file_size and upload_date even though this information could theoretically be retrieved from the storage system. Storing metadata locally enables fast queries filtering or sorting by size or date without calling external APIs.

The Reports table stores references to detection results but also caches key prediction information in the report to ensure reports remain readable even if the underlying detection results are archived or deleted. File paths or storage keys are stored in the database even though they could be computed from UUIDs and timestamps, avoiding the overhead of reconstructing paths for every file access. User display names combining first_name and last_name could be computed on each query but are sometimes cached in session data to reduce database hits for frequent operations. These pragmatic denormalizations recognize that absolute normalization can create artificial performance barriers, and judicious redundancy that's properly managed can improve system responsiveness without compromising data integrity.

The normalization strategy for OralCare AI balances theoretical purity with practical performance requirements, achieving 3NF for core data while accepting targeted denormalization where query performance or operational simplicity justify the controlled redundancy. This approach ensures data integrity and maintainability while delivering the query performance necessary for responsive user experiences.

