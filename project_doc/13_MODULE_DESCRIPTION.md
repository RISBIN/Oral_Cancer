# CHAPTER 8: MODULE DESCRIPTION

## Overview

The OralCare AI system architecture organizes functionality into modular components that encapsulate specific responsibilities, maintain clear boundaries, and communicate through well-defined interfaces. This modular design follows software engineering principles of separation of concerns, high cohesion within modules, and low coupling between modules, enabling independent development, testing, and maintenance of each component while ensuring they collectively deliver comprehensive oral cancer screening capabilities. The system comprises five primary modules including the Accounts Module managing user authentication and profile data, the Detection Module handling image upload and AI analysis, the Reports Module generating clinical documentation, the Dashboard Module providing administrative oversight, and the Core Module supplying shared utilities and configurations used across the application. Each module implements a complete vertical slice of functionality from database models through business logic to user interface components, allowing developers to understand and modify features without navigating the entire codebase. The module boundaries reflect natural domain divisions in the healthcare screening workflow, with each module addressing distinct user needs and system capabilities while integrating seamlessly to create a unified application experience.

## Accounts Module

### Purpose and Scope

The Accounts Module serves as the foundation of the OralCare AI system by implementing comprehensive user management functionality including registration, authentication, authorization, profile management, and role-based access control. This module recognizes that effective healthcare AI systems must support diverse user types with different needs and permissions, from doctors performing clinical screenings to administrators managing system operations to researchers analyzing aggregate data to students learning oral pathology. The module extends Django's built-in authentication framework with healthcare-specific fields and role-based permissions, ensuring that security and access control meet the requirements of medical applications handling sensitive patient data. By centralizing all user-related functionality in a dedicated module, the system maintains consistent authentication logic, simplifies permission management, and provides a single source of truth for user information referenced throughout the application.

### Key Components

The User model extends Django's AbstractUser base class inheriting standard authentication fields like username, email, and password while adding healthcare-specific attributes including role designation determining access permissions, institutional affiliation identifying the user's organization, contact information enabling communication, professional biography providing context about qualifications, profile picture URL personalizing the interface, and email verification status confirming account ownership. The model implements custom methods checking role-based permissions such as whether users can upload images, generate reports, or access analytics dashboards, encapsulating authorization logic within the model rather than scattering permission checks throughout view code. Database indexes on frequently queried fields like email and role optimize authentication queries and user searches, ensuring responsive login experiences and efficient administrative interfaces.

The registration system implements a multi-step workflow beginning with form submission capturing required information, validating inputs to ensure data quality and uniqueness, creating inactive user accounts awaiting verification, sending email verification links containing cryptographic tokens, and activating accounts when users click verification links confirming email ownership. The RegistrationForm extends Django's UserCreationForm with additional fields and custom validation methods checking email uniqueness to prevent duplicate accounts, enforcing password strength requirements mandating minimum length and complexity, validating password confirmation matching to prevent typos, and sanitizing text inputs to prevent injection attacks. The registration view coordinates form rendering, validation error display, user creation, email sending, and redirect flow, providing clear feedback at each step to guide users through the registration process.

The authentication system supports flexible login accepting either username or email as identifier for user convenience, implements secure password verification using Django's PBKDF2 hashing algorithm with sufficient iterations to resist brute-force attacks, creates authenticated sessions storing user identity across requests, and supports remember-me functionality extending session duration for users who opt in. The login view authenticates credentials against the database, checks account status ensuring only active verified accounts can login, creates session tokens stored in HTTP-only secure cookies preventing JavaScript access and transmission over unencrypted connections, and redirects users to their intended destination or default dashboard. Account lockout mechanisms could be added to prevent credential stuffing attacks after repeated failed login attempts, though the current implementation relies on rate limiting middleware to throttle authentication requests.

The profile management system enables users to view and update their information including name, institution, contact details, and profile pictures, with changes validated and persisted to the database. The profile view retrieves current user data from the database, renders forms pre-populated with existing values, validates submitted changes ensuring data integrity, updates database records within transactions ensuring atomicity, and logs modifications in audit trails for accountability. Profile pictures upload to Supabase Storage with URLs saved in the user profile, following the same pattern as image uploads but with different storage paths and access controls. Email changes require re-verification to prevent account hijacking, sending verification links to new addresses before updating the email field.

The password management system implements secure password reset workflows protecting against unauthorized account access while enabling legitimate users to recover from forgotten passwords. The forgot password view accepts email addresses, generates cryptographic tokens valid for limited time periods, sends password reset links to verified email addresses, and displays success messages without revealing whether accounts exist to prevent email enumeration. The password reset view validates tokens confirming they are current and match the requesting user, renders password change forms with strength requirements, updates password hashes using secure algorithms, invalidates old sessions forcing re-login, and confirms successful password changes. Password history could be maintained to prevent reuse of recent passwords, though the current implementation focuses on strength requirements rather than history restrictions.

### Module Interactions

The Accounts Module serves as a foundational dependency for all other modules since every feature requires knowing the authenticated user's identity and permissions. The Detection Module queries user information to associate uploaded images with owners, enforce upload quotas, and filter result views to show only authorized data. The Reports Module references user data to populate provider information in generated PDFs and to restrict report access to creators. The Dashboard Module checks user roles to determine which administrative functions to display and which data to include in analytics. The Core Module utilities access user context for logging, error reporting, and audit trails. Session middleware from Django's authentication system runs on every request, retrieving user objects from session tokens and making them available to views through the request.user attribute, enabling consistent authentication throughout the application without explicit user retrieval in every view.

## Detection Module

### Purpose and Scope

The Detection Module implements the core artificial intelligence functionality that distinguishes OralCare AI from traditional image management systems, orchestrating the complete workflow from image upload through preprocessing to model inference to result storage and display. This module recognizes that accurate oral cancer screening requires not only sophisticated AI algorithms but also robust image handling, comprehensive validation, efficient storage, and clear presentation of results that healthcare providers can interpret and act upon. The module integrates multiple technologies including Django for request handling and data persistence, Supabase Storage for scalable file management, TensorFlow for AI model execution, NumPy for numerical processing, and Pillow for image manipulation, coordinating these components into seamless workflows that abstract complexity from users who simply upload images and receive predictions. By encapsulating all detection-related functionality in a dedicated module, the system maintains clean separation between AI operations and other concerns like user management or reporting, enabling specialized development and testing of machine learning components.

### Key Components

The Image model represents uploaded photographs in the database, storing metadata including filename preserving the original name for user reference, file URL pointing to the Supabase Storage location enabling direct browser access, file path containing the storage key for API operations, file size tracking upload dimensions for analytics and quota enforcement, upload timestamp recording when images were submitted, processing status indicating current workflow stage from pending to processing to processed or failed, and optional notes capturing user observations about the image. Foreign key relationships link images to uploading users enabling ownership queries and access control, while reverse relationships to detection results enable efficient retrieval of all analyses for an image. Model methods implement business logic including checking whether results exist, retrieving consensus predictions when multiple models agree, and formatting display values like human-readable status labels.

The image upload workflow begins with the upload form accepting file inputs with validation rules, submitting files through multipart form encoding required for binary data, displaying progress indicators during transmission for large files, and showing thumbnails after successful upload for confirmation. The ImageUploadForm implements validation checking file type against allowed extensions preventing upload of non-image formats, enforcing size limits preventing excessive storage consumption and processing time, and sanitizing filenames removing potentially dangerous characters. The upload view coordinates the workflow by validating forms with clear error messages for rejections, reading uploaded files from request.FILES dictionary, invoking Supabase Storage client to persist files with organized paths, creating Image database records with metadata and storage references, initiating AI detection processing, and redirecting to results pages or showing errors.

The Supabase Storage integration implements a clean abstraction over cloud storage operations, hiding implementation details behind simple upload, download, and delete methods. The SupabaseStorage class initializes authenticated clients using environment-configured credentials, generates organized file paths following the pattern user-id/year/month/day/uuid-filename preventing collisions and enabling efficient organization, uploads files through API calls with appropriate content types and cache headers, retrieves public URLs enabling direct browser access for authorized users, downloads file data for processing without exposing storage internals, and deletes files when images are removed from the system. Error handling wraps storage exceptions with user-friendly messages, logging detailed errors for debugging while presenting simplified feedback to users.

The AI detection workflow orchestrates preprocessing, inference, and result storage through coordinated functions that transform uploaded images into actionable predictions. The detection pipeline begins by downloading images from Supabase Storage into memory, preprocessing images through resizing to 224x224 pixels required by model architectures using high-quality Lanczos resampling, converting color spaces to RGB ensuring consistent input representation, normalizing pixel values to ranges expected by models based on training, and adding batch dimensions wrapping single images in arrays for inference APIs. Model inference loads pre-trained RegNetY320 and VGG16 neural networks at application startup avoiding repeated initialization overhead, executes predictions by passing preprocessed images through model forward passes computing activations, extracts confidence scores from final layer outputs indicating classification certainty, applies thresholds converting probabilities to binary Cancer or Non-Cancer predictions, and measures processing time for performance monitoring.

The DetectionResult model persists AI predictions in the database with foreign keys linking results to analyzed images and requesting users, model name identifying which architecture produced the prediction enabling comparisons, prediction classification as Cancer or Non-Cancer providing actionable outputs, confidence score storing the raw probability value for nuanced interpretation, processing time recording inference duration for performance analysis, model version tracking which weights produced predictions enabling historical analysis when models are updated, and timestamps recording when predictions occurred. Multiple DetectionResult records exist for each Image when both models analyze the same photograph, with queries efficiently retrieving all results through foreign key relationships and joins. Model methods format confidence as percentages for display, check for consensus between models, and compute aggregate statistics across result sets.

The results display interface renders prediction outputs with visual design emphasizing critical information, using color-coded indicators highlighting Cancer predictions in red or orange warning colors demanding attention while Non-Cancer classifications use green or blue suggesting lower concern, displaying confidence scores both numerically as percentages and graphically through progress bars providing at-a-glance assessment, positioning dual-model results side-by-side enabling immediate comparison, and highlighting consensus when models agree increasing clinical confidence. Interactive features include image zoom for detailed examination, toggles between original and preprocessed images showing what the AI analyzed, action buttons for report generation linking to downstream workflows, re-analysis triggering new inference useful when models are updated, and deletion removing results while optionally preserving source images. The results view queries detection results and images through foreign key relationships, checks user permissions ensuring access restrictions, renders templates with context data, and handles actions through form submissions.

### Module Interactions

The Detection Module depends on the Accounts Module for user authentication and authorization, querying user objects to associate uploads with owners and checking permissions before allowing image uploads or result access. The module integrates with Supabase cloud services through API clients for storage operations, making authenticated requests to upload, download, and delete files with error handling for network issues or service outages. The Reports Module depends on the Detection Module to retrieve results for PDF generation, querying DetectionResult and Image models to populate report content. The Dashboard Module aggregates detection statistics for analytics, counting results by prediction class, computing average confidence scores, and tracking processing times. The Core Module provides shared utilities for file handling, logging, and configuration that the Detection Module leverages for consistent behavior.

## Reports Module

### Purpose and Scope

The Reports Module transforms raw AI detection outputs into professional clinical documentation suitable for medical records, specialist referrals, and patient communication, recognizing that healthcare providers need more than numerical predictions to take action and that formal reports provide essential documentation for care continuity and legal protection. This module implements comprehensive PDF generation capabilities that assemble patient information, clinical images, AI predictions, provider observations, and standardized recommendations into polished documents meeting medical documentation standards. The module addresses the reality that healthcare workflows require paper or PDF records that can be printed, faxed, archived in charts, or sent to specialists who may not have access to the OralCare AI system, ensuring that AI-generated insights translate into actionable next steps within existing clinical processes. By providing flexible report generation with optional patient information respecting privacy needs and customizable clinical notes supporting provider judgment, the module ensures that AI serves as a tool augmenting rather than replacing professional expertise.

### Key Components

The Report model persists metadata about generated PDF documents, storing foreign keys linking reports to generating users and associated detection results enabling traceability, optional patient information including name, age, gender, and medical record number supporting identification while allowing anonymity when appropriate, clinical notes capturing provider observations and interpretations adding human context to algorithmic predictions, PDF storage references including Supabase Storage paths and public URLs enabling retrieval, generation timestamps recording when reports were created, and audit fields tracking modifications. The model implements methods for formatting display values, retrieving related detection results and images through foreign key relationships, and checking access permissions. Database indexes optimize queries filtering reports by user, date, or patient name, ensuring responsive searches through potentially large report collections.

The report generation form captures information needed to create comprehensive PDF documents, defining fields for patient demographics with optional flags respecting privacy when providers choose not to include identifying information, medical record numbers linking reports to institutional patient databases, clinical notes text areas accepting free-form provider observations with character limits preventing excessive verbosity, and report options controlling which sections to include. Form validation ensures data quality through type checking confirming ages are numeric and within reasonable ranges, length limits preventing buffer overflows or database constraint violations, text sanitization removing dangerous HTML or script injections, and cross-field validation checking related field consistency. Form rendering uses Bootstrap styling for professional appearance, includes placeholders and help text guiding users, and implements responsive design adapting to different screen sizes.

The PDF generation system implements sophisticated document assembly using ReportLab library capabilities, constructing professional layouts with standard letter or A4 page sizes supporting international preferences, margin definitions providing comfortable reading spacing, multi-column layouts presenting information efficiently, and header/footer sections with metadata and page numbers. The OralCareReportGenerator class encapsulates PDF creation logic, defining custom paragraph styles for titles, section headers, body text, disclaimers, and footers with font selections, sizes, colors, and spacing, organizing content into story arrays of flowable elements processed sequentially, managing page breaks ensuring logical section divisions, and generating final PDF bytes written to buffers for upload. Document sections include header banners with title and generation timestamp, patient information tables displaying demographics and record numbers, clinical image sections embedding uploaded photographs with appropriate sizing, detection results tables presenting model predictions with confidence scores in structured format, clinical notes sections incorporating provider observations, recommendations sections suggesting next steps based on predictions, and disclaimer text clearly stating AI limitations and the primacy of clinical judgment.

The report generation workflow coordinates multiple systems to produce final documents, beginning with the generation view authenticating users and checking permissions, retrieving detection results and images through foreign key queries, rendering forms for patient information and notes, validating submissions with error handling, constructing report data dictionaries with all required information, invoking PDF generator with data parameters, receiving PDF bytes in memory buffers, uploading PDFs to Supabase Storage in organized paths, creating Report database records with storage references, and redirecting to download pages or showing success confirmations. Error handling throughout the workflow catches generation failures, storage errors, or permission violations, logging detailed diagnostics while showing user-friendly messages enabling retry or support contact.

The report download system retrieves generated PDFs from storage and delivers them to users through HTTP responses, implementing the download view by authenticating users and checking ownership, querying Report records by ID, retrieving file paths from database records, downloading PDF bytes from Supabase Storage, constructing FileResponse objects with appropriate content types signaling to browsers that these are PDF documents, setting content-disposition headers triggering download dialogs rather than in-browser display if desired, and streaming file data efficiently for large documents. The report history interface displays all reports generated by the current user in reverse chronological order, showing patient names or anonymous indicators, generation dates, quick download links, and deletion options, with pagination for users with many reports and filters for searching by patient name or date range.

### Module Interactions

The Reports Module depends heavily on the Detection Module to retrieve results for inclusion in PDFs, querying DetectionResult and Image models through foreign key relationships to populate report content with predictions, confidence scores, model names, and image URLs. The module depends on the Accounts Module for user authentication and to retrieve provider information like name and institution for report footers. The module integrates with Supabase Storage through the same client used by the Detection Module, uploading generated PDFs with organized paths and retrieving them for download. The Dashboard Module may aggregate report statistics counting total reports generated, reports per user, or reports by time period for administrative analytics. The Core Module provides shared utilities for file handling, error logging, and configuration that the Reports Module leverages.

## Dashboard Module

### Purpose and Scope

The Dashboard Module provides administrative oversight and analytics capabilities enabling system administrators to monitor operations, manage users, track usage patterns, and ensure system health, recognizing that production systems require ongoing management and that data-driven insights inform decisions about capacity planning, feature priorities, and operational improvements. This module implements role-based dashboards presenting different views and capabilities based on user roles, with administrators accessing comprehensive system management while doctors see clinical summaries and researchers view aggregate analytics. The module emphasizes actionable metrics and efficient workflows, avoiding information overload by highlighting critical indicators while providing drill-down capabilities for detailed investigation. By centralizing administrative functionality in a dedicated module, the system maintains clear separation between end-user features and system management concerns, enabling specialized security controls and reducing the risk that administrative errors impact clinical operations.

### Key Components

The dashboard views implement role-specific landing pages that users see after login, with routing logic checking user roles and redirecting to appropriate dashboards. The doctor dashboard displays personal statistics including total images uploaded, images processed, reports generated, and detection counts by prediction class, recent activity showing the five most recent uploads with thumbnails and statuses, quick action buttons for common tasks like uploading new images or generating reports, and notifications about pending verifications or failed processing requiring attention. The administrator dashboard presents system-wide metrics including total registered users segmented by role, total images and reports across all users, detection statistics with cancer vs non-cancer ratios, and system performance indicators like average processing time and error rates. The researcher dashboard focuses on aggregate analytics with detection statistics over time, model performance comparisons, confidence score distributions, and data export capabilities for external analysis.

The user management interface enables administrators to oversee user accounts through searchable tables displaying all registered users with columns for name, email, role, institution, registration date, and account status. Administrative actions include creating new accounts manually with role assignment useful for bulk provisioning or supporting users without email access, editing user details to correct information or change roles, activating or deactivating accounts controlling access without deleting data, resetting passwords for users locked out of accounts, and deleting accounts when necessary with cascade or preservation of associated data depending on data retention policies. User search and filtering enable finding specific accounts by name, email, role, or institution, with pagination for large user populations and bulk selection for operations affecting multiple users. User activity logs display authentication events, upload actions, detection requests, report generation, and administrative actions providing audit trails for security investigations and compliance reporting.

The system monitoring dashboard tracks operational metrics essential for maintaining service quality, displaying server resource utilization including CPU load, memory consumption, and disk space with trend graphs showing changes over time, database performance metrics like query response times, connection counts, and slow query logs identifying optimization opportunities, AI inference performance measuring model latency, throughput, and resource usage, and error rates with detailed logs for troubleshooting. Alert configuration enables setting thresholds for automated notifications when metrics exceed acceptable ranges, ensuring rapid response to performance degradations or outages before users are significantly impacted. Integration with external monitoring services like Sentry for error tracking, Datadog for infrastructure monitoring, or New Relic for application performance management could extend observability capabilities beyond built-in dashboards.

The analytics and reporting interface provides insights into usage patterns, detection outcomes, and system effectiveness through visualization of key metrics. Usage analytics track image uploads over time with daily, weekly, or monthly aggregations, detection requests by model, reports generated, and active user counts identifying engagement levels. Detection analytics show prediction distributions comparing cancer vs non-cancer classifications, confidence score distributions revealing model certainty patterns, model agreement rates indicating consensus frequency, and processing times tracking performance. User analytics segment metrics by role, institution, or registration cohort revealing usage patterns across different user populations. Data export functionality generates CSV or JSON files containing aggregate or detailed data for external analysis in statistical software or spreadsheet applications, respecting privacy by excluding patient identifiable information unless explicitly authorized.

### Module Interactions

The Dashboard Module depends on all other modules to retrieve data for analytics, querying the User model from Accounts Module for user counts and demographics, querying Image and DetectionResult models from Detection Module for detection statistics, querying Report model from Reports Module for reporting metrics, and accessing system logs and performance metrics from Core Module monitoring utilities. The module enforces strict permission checks ensuring only authorized users access administrative functions, with view decorators verifying user roles before rendering dashboards or processing actions. The module does not typically store its own data but rather aggregates and presents information from other modules, implementing read-only analytics views and administrative actions that modify data in source modules through their defined interfaces.

## Core Module

### Purpose and Scope

The Core Module provides shared utilities, configurations, and infrastructure components used throughout the OralCare AI application, implementing cross-cutting concerns that don't belong to any specific feature module but are essential for system operation. This module recognizes that production applications require sophisticated supporting infrastructure beyond business logic, including configuration management adapting behavior to different environments, logging and error tracking for debugging and monitoring, middleware processing requests before they reach views, management commands for administrative tasks, template tags extending template functionality, signal handlers coordinating actions across models, and test utilities supporting comprehensive quality assurance. By centralizing these shared components in a dedicated module, the system avoids code duplication, ensures consistent behavior across features, and provides a single location for infrastructure improvements that benefit the entire application.

### Key Components

The configuration management system organizes Django settings into environment-specific modules with settings/base.py containing common configuration shared across all environments, settings/development.py extending base settings with developer-friendly options like debug mode enabled and simplified authentication, settings/staging.py mirroring production configuration but using separate infrastructure, and settings/production.py implementing security hardening and performance optimizations. Environment variables loaded through python-decouple or django-environ provide sensitive configuration like database credentials, Supabase API keys, secret keys for cryptographic operations, and third-party service credentials without storing them in code or version control. Settings validation at application startup confirms required configuration is present, preventing runtime failures from missing values.

The logging configuration establishes structured logging throughout the application, defining formatters specifying log message layout with timestamps, severity levels, logger names, and message content, configuring handlers directing logs to appropriate destinations like console output for development, file logs for production persistence, or external services like Sentry for centralized error tracking, setting log levels controlling verbosity from DEBUG for comprehensive developer information through INFO for significant events to WARNING and ERROR for problems requiring attention, and creating logger hierarchies organizing loggers by module with different levels and handlers. Application code retrieves loggers by name and emits structured log messages at appropriate levels, enabling filtering, searching, and alerting based on log metadata.

The middleware stack implements request and response processing that runs on every HTTP request, with Django's default middleware providing session management, authentication, CSRF protection, and security headers, while custom middleware could add request logging recording all requests with timestamps, user identities, URLs, and response codes for analytics and debugging, performance monitoring measuring request processing time and logging slow requests, error handling catching exceptions and rendering user-friendly error pages while logging details for investigation, and custom headers adding application-specific HTTP headers for security or functionality. Middleware ordering matters since later middleware sees modifications from earlier middleware, requiring careful arrangement to ensure proper behavior.

The management commands extend Django's manage.py with custom administrative tasks useful for operations, maintenance, and testing. Example commands include data import commands loading initial data or migrating from legacy systems, cleanup commands removing old temporary files or expired sessions, reporting commands generating periodic summaries or exports, testing commands running specialized test suites or data validations, and deployment commands coordinating multi-step deployment procedures. Commands implement handle methods containing task logic, define command-line arguments for flexibility, emit progress messages for long-running operations, and handle errors gracefully with rollback for database operations.

The template tags and filters extend Django's template language with application-specific functionality, defining custom tags for common UI patterns like rendering user avatars, displaying relative timestamps, or formatting confidence scores, implementing filters transforming template variables like converting decimals to percentages, truncating long text, or formatting dates, and registering tags through template tag libraries loaded in templates with {% load %} directives. Template tags access database data, perform calculations, or render complex HTML structures difficult to express with built-in template syntax, while filters transform individual values in place enabling method chaining.

The signal handlers coordinate actions across models when specific events occur, connecting to Django's signal system that emits signals for model lifecycle events like pre_save before model instances are saved, post_save after successful saves, pre_delete before deletions, and post_delete after deletions. Custom signal handlers implement cross-model coordination like updating related records when data changes, maintaining denormalized counts or computed fields, sending notifications when important events occur, or logging model changes for audit trails. Handlers connect to signals through decorators or explicit registration, receive sender models and instance parameters, and execute quickly to avoid blocking request processing.

The testing utilities provide shared fixtures, factories, and helpers used across test suites, defining fixture factories generating realistic test data using libraries like factory_boy, creating mock objects simulating external services like Supabase Storage or email backends, implementing assertion helpers checking complex conditions concisely, and providing test case base classes with common setup and teardown. Shared test utilities ensure consistency across module test suites, reduce duplication of test infrastructure code, and simplify writing comprehensive tests.

### Module Interactions

The Core Module serves as a dependency for all other modules since every module relies on shared configuration, logging, and utilities. Other modules import settings to access configuration values, retrieve loggers to emit log messages, inherit from custom middleware or authentication backends, use template tags in their templates, and leverage test utilities in their test suites. The Core Module typically does not depend on feature modules to avoid circular dependencies, instead providing generic utilities that feature modules adapt to their specific needs. When core utilities need feature-specific behavior, they accept callbacks or use Django's signal system rather than directly importing from feature modules.

## Module Integration and System Architecture

The five primary modules integrate through well-defined interfaces forming a cohesive system where each module contributes specialized capabilities while remaining independently testable and maintainable. The Accounts Module provides authentication and user management used by all other modules to identify requesting users and enforce permissions. The Detection Module implements core AI functionality depending on Accounts for user context and providing detection results to Reports and Dashboard modules. The Reports Module generates clinical documentation from detection results, depending on both Detection and Accounts modules for content and context. The Dashboard Module aggregates data from all modules to provide administrative oversight without owning primary data. The Core Module supports all modules with shared infrastructure, configuration, and utilities. This modular architecture enables parallel development where teams work on different modules simultaneously, facilitates testing by allowing modules to be tested with mocked dependencies, simplifies maintenance by containing changes within module boundaries, and supports future extensibility where new modules integrate by depending on existing module interfaces without requiring internal modifications.

The module structure reflects careful analysis of the healthcare screening domain, organizing functionality around natural workflow stages from user registration through image upload through AI analysis through report generation through administrative oversight. This domain-driven design ensures that modules align with how users think about the system, making the codebase easier to understand for developers new to the project and simplifying communication between technical and non-technical stakeholders who can discuss features in terms of modules that map to their mental models. The modular architecture positions OralCare AI for future enhancements like adding new AI models, integrating with electronic health record systems, supporting multi-language interfaces, or deploying specialized versions for different clinical settings, all achievable through module extensions or new module additions that leverage the existing infrastructure.
